import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { createRoot } from 'react-dom/client';
import {
  ReactFlow,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
  addEdge,
  MarkerType,
  Handle,
  Position,
  BaseEdge,
  EdgeLabelRenderer,
  getSmoothStepPath,
} from '@xyflow/react';
import '@xyflow/react/dist/style.css';
import statsData from '../data/stats.json';

const { ipcRenderer, screen } = window.require ? window.require('electron') : { ipcRenderer: null, screen: null };

// Lista de modificadores dispon√≠veis (PoE2)
const MODIFIERS = (() => {
  const list = [];
  const groups = Array.isArray(statsData?.result) ? statsData.result : [];
  for (const group of groups) {
    const groupLabel = group?.label || group?.id || 'Outros';
    const entries = Array.isArray(group?.entries) ? group.entries : [];
    for (const entry of entries) {
      if (entry?.text) {
        list.push({
          id: entry.id || entry.text,
          text: entry.text,
          group: groupLabel,
          type: entry.type || group?.id || 'unknown'
        });
      }
    }
  }
  return list;
})();

const NODE_TYPES = {
  start: { label: '‚ñ∂Ô∏è In√≠cio', color: '#51cf66', icon: '‚ñ∂Ô∏è' },
  end: { label: '‚èπÔ∏è Fim', color: '#ff6b6b', icon: '‚èπÔ∏è' },
  leftClick: { label: 'üñ±Ô∏è Clique Esquerdo', color: '#6bd17c', icon: 'üñ±Ô∏è' },
  rightClick: { label: 'üñ±Ô∏è Clique Direito', color: '#d4a351', icon: 'üñ±Ô∏è' },
  checkRegion: { label: 'üîç Verificar Regi√£o', color: '#f0b45a', icon: 'üîç' },
  delay: { label: '‚è±Ô∏è Delay', color: '#8b7ba8', icon: '‚è±Ô∏è' },
};

// N√≥ individual
function Node({ data, id, isConnectable, onUpdate, onDelete, onEdit }) {
  const [formData, setFormData] = useState(data);
  const capturingRef = useRef(false);
  const capturingTooltipRef = useRef(false);

  const filteredModifiers = useMemo(() => {
    const query = modSearch.trim().toLowerCase();
    if (!query) return MODIFIERS.slice(0, 20);
    return MODIFIERS
      .filter(mod => mod.text.toLowerCase().includes(query) || mod.group.toLowerCase().includes(query))
      .slice(0, 30);
  }, [modSearch]);

  // Sincronizar formData com data quando data mudar (quando salvar)
  useEffect(() => {
    if (data?.type === 'checkRegion' && !data.modifierList && data.modifierText) {
      setFormData({
        ...data,
        modifierList: [
          {
            id: data.modifierId || data.modifierText,
            text: data.modifierText,
            pattern: data.modifierText,
            minValue: null,
            maxValue: null,
            useRange: false
          }
        ]
      });
      return;
    }
    setFormData(data);
  }, [data]);

  useEffect(() => {
    const handleCapture = (event) => {
      if (!capturingRef.current || event.detail.nodeId !== id) return;
      const { position, screenWidth, screenHeight } = event.detail;

      // Calcula coordenadas relativas (percentuais)
      const relativeX = (position.x / screenWidth) * 100;
      const relativeY = (position.y / screenHeight) * 100;

      setFormData(prev => ({
        ...prev,
        position: {
          x: position.x,
          y: position.y,
          relativeX: relativeX,
          relativeY: relativeY
        }
      }));
      capturingRef.current = false;
    };

    const handleRegionCapture = (event) => {
      if (!capturingTooltipRef.current || event.detail.nodeId !== id) return;
      const { region, screenWidth, screenHeight } = event.detail;

      // Calcula coordenadas relativas (percentuais)
      const relativeX = (region.x / screenWidth) * 100;
      const relativeY = (region.y / screenHeight) * 100;
      const relativeWidth = (region.width / screenWidth) * 100;
      const relativeHeight = (region.height / screenHeight) * 100;

      setFormData(prev => ({
        ...prev,
        region: {
          ...region,
          relativeX: relativeX,
          relativeY: relativeY,
          relativeWidth: relativeWidth,
          relativeHeight: relativeHeight
        }
      }));
      capturingTooltipRef.current = false;
    };

    window.addEventListener('flowEditorPositionSelected', handleCapture);
    window.addEventListener('flowEditorTooltipRegionSelected', handleRegionCapture);
    return () => {
      window.removeEventListener('flowEditorPositionSelected', handleCapture);
      window.removeEventListener('flowEditorTooltipRegionSelected', handleRegionCapture);
    };
  }, [id]);

  const typeColor = NODE_TYPES[data.type]?.color || '#8b7ba8';
  const textColor = data.type === 'leftClick' ? '#0a1a0f' : '#1a1307';
  const isSystemNode = data.type === 'start' || data.type === 'end';
  const nodeStyle = isSystemNode
    ? {
        background: 'linear-gradient(135deg, rgba(28, 25, 34, 0.95), rgba(42, 42, 50, 0.9))',
        color: '#e8e8ea',
        border: '2px solid rgba(212, 163, 81, 0.4)',
        boxShadow: '0 8px 24px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(212, 163, 81, 0.15) inset'
      }
    : {
        background: `linear-gradient(135deg, ${typeColor}dd, ${typeColor}aa)`,
        color: textColor,
        border: `2px solid ${typeColor}`,
        boxShadow: `0 8px 24px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1) inset, 0 0 20px ${typeColor}33`
      };

  // Usar nome customizado se existir, sen√£o usar label padr√£o
  const displayLabel = data.customName || data.label;

  return (
    <div style={{ ...nodeStyle, fontWeight: '600', borderRadius: '12px', padding: '12px 16px', minWidth: '300px', textAlign: 'center', fontSize: '0.88rem', position: 'relative', backdropFilter: 'blur(10px)', transition: 'all 0.2s ease' }}>
      {data.type !== 'start' && <Handle type="target" position={Position.Top} isConnectable={isConnectable} style={{ width: '14px', height: '14px', border: '2px solid rgba(0,0,0,0.3)', boxShadow: '0 0 10px rgba(212, 163, 81, 0.5)', background: '#d4a351' }} />}
      {displayLabel}
      {data.position && <div style={{ fontSize: '0.7rem', color: 'rgba(0,0,0,0.5)', marginTop: '2px' }}>{data.position.x},{data.position.y}</div>}
      {data.delayMs && <div style={{ fontSize: '0.7rem', color: 'rgba(0,0,0,0.5)' }}>+{data.delayMs}ms</div>}
      {data.useShift && <div style={{ fontSize: '0.7rem', color: 'rgba(0,0,0,0.5)' }}>‚¨ÜÔ∏è Shift</div>}
      {data.type === 'checkRegion' && data.region && <div style={{ fontSize: '0.65rem', color: 'rgba(0,0,0,0.5)', marginTop: '2px' }}>R: {data.region.x},{data.region.y}</div>}
      {data.type === 'checkRegion' && Array.isArray(data.modifierList) && data.modifierList.length > 0 && (
        <div style={{ fontSize: '0.7rem', color: 'rgba(255,255,255,0.8)', marginTop: '6px', background: 'rgba(0,0,0,0.25)', padding: '4px 8px', borderRadius: '6px', fontWeight: '500', border: '1px solid rgba(255,255,255,0.1)' }}>
          üîç Mods: {data.modifierList.length} ‚Ä¢ {data.modifierList[0].text?.substring(0, 28) || data.modifierList[0].pattern?.substring(0, 28)}{(data.modifierList[0].text || data.modifierList[0].pattern || '').length > 28 ? '...' : ''}
        </div>
      )}
      {!isSystemNode && (
        <div style={{ display: 'flex', gap: '6px', marginTop: '8px', justifyContent: 'center' }}>
          <button onClick={() => onEdit(id, data)} style={{ padding: '4px 10px', fontSize: '0.7rem', background: 'rgba(212, 163, 81, 0.25)', border: '1px solid rgba(212, 163, 81, 0.4)', borderRadius: '6px', color: '#f6f1e4', cursor: 'pointer', fontWeight: '500', transition: 'all 0.2s ease', backdropFilter: 'blur(4px)' }}>‚úèÔ∏è</button>
          <button onClick={() => onDelete(id)} style={{ padding: '4px 10px', fontSize: '0.7rem', background: 'rgba(255, 107, 107, 0.25)', border: '1px solid rgba(255, 107, 107, 0.4)', borderRadius: '6px', color: '#ffd4d4', cursor: 'pointer', fontWeight: '500', transition: 'all 0.2s ease', backdropFilter: 'blur(4px)' }}>‚úï</button>
        </div>
      )}

      {data.type === 'checkRegion' ? (
        <>
          <Handle id="false" type="source" position={Position.Bottom} isConnectable={isConnectable} style={{ left: '30%', backgroundColor: '#ff6b6b', width: '14px', height: '14px', border: '2px solid rgba(0,0,0,0.3)', boxShadow: '0 0 10px rgba(255, 107, 107, 0.5)' }} />
          <Handle id="true" type="source" position={Position.Bottom} isConnectable={isConnectable} style={{ left: '70%', backgroundColor: '#51cf66', width: '14px', height: '14px', border: '2px solid rgba(0,0,0,0.3)', boxShadow: '0 0 10px rgba(81, 207, 102, 0.5)' }} />
          <div style={{ position: 'absolute', bottom: '-20px', left: '22%', fontSize: '0.68rem', color: '#ff6b6b', fontWeight: '600', textShadow: '0 0 4px rgba(0,0,0,0.8)' }}>N√£o</div>
          <div style={{ position: 'absolute', bottom: '-20px', left: '64%', fontSize: '0.68rem', color: '#51cf66', fontWeight: '600', textShadow: '0 0 4px rgba(0,0,0,0.8)' }}>Sim</div>
        </>
      ) : data.type !== 'end' ? (
        <Handle type="source" position={Position.Bottom} isConnectable={isConnectable} style={{ width: '14px', height: '14px', border: '2px solid rgba(0,0,0,0.3)', boxShadow: '0 0 10px rgba(212, 163, 81, 0.5)' }} />
      ) : null}
    </div>
  );
}

function DeletableEdge({ id, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, style, markerEnd, onDelete, showDelete }) {
  const [edgePath, labelX, labelY] = getSmoothStepPath({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourcePosition,
    targetPosition,
  });

  return (
    <>
      <BaseEdge id={id} path={edgePath} style={style} markerEnd={markerEnd} />
      <EdgeLabelRenderer>
        <button
          onClick={(e) => { e.stopPropagation(); onDelete(id); }}
          style={{
            position: 'absolute',
            transform: `translate(-50%, -50%) translate(${labelX}px, ${labelY}px)`,
            width: '18px',
            height: '18px',
            borderRadius: '50%',
            border: '1px solid rgba(212, 163, 81, 0.6)',
            background: 'rgba(20, 17, 26, 0.95)',
            color: '#e7c889',
            fontSize: '12px',
            cursor: 'pointer',
            opacity: showDelete ? 1 : 0,
            pointerEvents: showDelete ? 'all' : 'none',
            transition: 'opacity 120ms ease-in-out',
          }}
          title="Remover conex√£o"
        >
          √ó
        </button>
      </EdgeLabelRenderer>
    </>
  );
}

// Toolbar Item Component (Drag Source)
function ToolbarItem({ type, label, icon, color, onAddNode }) {
  const onDragStart = (event) => {
    event.dataTransfer.setData('application/reactflow', JSON.stringify({ type }));
    event.dataTransfer.effectAllowed = 'move';
  };

  return (
    <div
      draggable
      onDragStart={onDragStart}
      onClick={() => onAddNode(type)}
      style={{
        background: color,
        borderRadius: '8px',
        padding: '12px',
        cursor: 'grab',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        gap: '4px',
        border: '2px solid rgba(0,0,0,0.2)',
        transition: 'all 0.2s ease',
        userSelect: 'none'
      }}
      onMouseDown={(e) => e.currentTarget.style.cursor = 'grabbing'}
      onMouseUp={(e) => e.currentTarget.style.cursor = 'grab'}
      title="Clique ou arraste para adicionar"
    >
      <div style={{ fontSize: '1.5rem' }}>{icon}</div>
      <div style={{ fontSize: '0.7rem', fontWeight: 'bold', color: 'rgba(0,0,0,0.8)', textAlign: 'center', lineHeight: '1.1' }}>
        {label}
      </div>
    </div>
  );
}

// Editor Principal
function FlowEditor() {
  const [nodes, setNodes, onNodesChange] = useNodesState([
    { id: 'start', type: 'node', data: { label: NODE_TYPES.start.label, type: 'start' }, position: { x: 250, y: 50 }, deletable: false },
    { id: 'end', type: 'node', data: { label: NODE_TYPES.end.label, type: 'end' }, position: { x: 250, y: 400 }, deletable: false },
  ]);

  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [hoveredEdgeId, setHoveredEdgeId] = useState(null);

  const [selectedType, setSelectedType] = useState('leftClick');
  const [flowMetadata, setFlowMetadata] = useState(() => ({
    createdAt: new Date().toISOString(),
    screenResolution: screen ? {
      width: screen.getPrimaryDisplay().bounds.width,
      height: screen.getPrimaryDisplay().bounds.height
    } : null
  }));

  const reactFlowWrapper = useRef(null);
  const [reactFlowInstance, setReactFlowInstance] = useState(null);

  const handleDeleteNode = (id) => {
    if (id === 'start' || id === 'end') return;
    setNodes(nds => nds.filter(n => n.id !== id));
    setEdges(eds => eds.filter(e => e.source !== id && e.target !== id));
  };

  const nodeTypes = useMemo(() => ({
    node: (props) => <Node {...props} onUpdate={(id, data) => setNodes(nds => nds.map(n => n.id === id ? { ...n, data } : n))} onDelete={handleDeleteNode} />
  }), [setNodes]);

  const edgeTypes = useMemo(() => ({
    deletable: (props) => (
      <DeletableEdge
        {...props}
        showDelete={hoveredEdgeId === props.id}
        onDelete={(edgeId) => setEdges(eds => eds.filter(e => e.id !== edgeId))}
      />
    )
  }), [setEdges, hoveredEdgeId]);

  const handleAddNode = (nodeType = null) => {
    const type = nodeType || selectedType;
    if (type === 'start' || type === 'end') return;
    const numericIds = nodes.map(n => parseInt(n.id)).filter(n => !isNaN(n));
    const newId = String(numericIds.length > 0 ? Math.max(...numericIds) + 1 : 1);
    setNodes(nds => [...nds, {
      id: newId,
      type: 'node',
      data: {
        label: NODE_TYPES[type].label,
        type: type,
        position: null,
        customName: '' // Nome vazio por padr√£o
      },
      position: { x: Math.random() * 400 + 100, y: Math.random() * 300 + 150 },
    }]);
  };

  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event) => {
      event.preventDefault();

      if (!reactFlowInstance) return;

      const type = JSON.parse(event.dataTransfer.getData('application/reactflow'));

      if (!type || !type.type) return;

      const position = reactFlowInstance.screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });

      const numericIds = nodes.map(n => parseInt(n.id)).filter(n => !isNaN(n));
      const newId = String(numericIds.length > 0 ? Math.max(...numericIds) + 1 : 1);

      const newNode = {
        id: newId,
        type: 'node',
        position,
        data: {
          label: NODE_TYPES[type.type].label,
          type: type.type,
          position: null,
          customName: ''
        },
      };

      setNodes((nds) => nds.concat(newNode));
    },
    [reactFlowInstance, nodes, setNodes]
  );

  const handleAutoLayout = () => {
    // Criar mapa de adjac√™ncias para encontrar a ordem dos n√≥s
    const adjacencyMap = {};
    nodes.forEach(node => {
      adjacencyMap[node.id] = [];
    });
    edges.forEach(edge => {
      if (!adjacencyMap[edge.source]) adjacencyMap[edge.source] = [];
      adjacencyMap[edge.source].push(edge.target);
    });

    // BFS para encontrar n√≠veis hier√°rquicos
    const levels = {};
    const visited = new Set();
    const queue = [{ id: 'start', level: 0 }];

    while (queue.length > 0) {
      const { id, level } = queue.shift();
      if (visited.has(id)) continue;
      visited.add(id);

      if (!levels[level]) levels[level] = [];
      levels[level].push(id);

      const neighbors = adjacencyMap[id] || [];
      neighbors.forEach(neighborId => {
        if (!visited.has(neighborId)) {
          queue.push({ id: neighborId, level: level + 1 });
        }
      });
    }

    // Adicionar n√≥s n√£o visitados (isolados) no final
    nodes.forEach(node => {
      if (!visited.has(node.id)) {
        const maxLevel = Math.max(...Object.keys(levels).map(k => parseInt(k)));
        const newLevel = maxLevel + 1;
        if (!levels[newLevel]) levels[newLevel] = [];
        levels[newLevel].push(node.id);
      }
    });

    // Posicionar n√≥s
    const HORIZONTAL_SPACING = 350;
    const VERTICAL_SPACING = 150;
    const START_X = 250;
    const START_Y = 50;

    const newNodes = nodes.map(node => {
      // Encontrar n√≠vel do n√≥
      let nodeLevel = 0;
      let positionInLevel = 0;

      for (const [level, nodesInLevel] of Object.entries(levels)) {
        const index = nodesInLevel.indexOf(node.id);
        if (index !== -1) {
          nodeLevel = parseInt(level);
          positionInLevel = index;
          break;
        }
      }

      const nodesInCurrentLevel = levels[nodeLevel] || [];
      const totalNodesInLevel = nodesInCurrentLevel.length;

      // Centralizar n√≥s no n√≠vel
      const levelWidth = (totalNodesInLevel - 1) * HORIZONTAL_SPACING;
      const startXForLevel = START_X - levelWidth / 2;

      return {
        ...node,
        position: {
          x: startXForLevel + positionInLevel * HORIZONTAL_SPACING,
          y: START_Y + nodeLevel * VERTICAL_SPACING
        }
      };
    });

    setNodes(newNodes);
  };

  const handleSave = () => {
    // Converter nodes para steps
    const steps = [];

    // Come√ßar do node start e seguir as conex√µes
    let currentNodeId = 'start';
    const visitedNodes = new Set();

    while (currentNodeId && currentNodeId !== 'end') {
      if (visitedNodes.has(currentNodeId)) break;
      visitedNodes.add(currentNodeId);

      const currentNode = nodes.find(n => n.id === currentNodeId);
      if (!currentNode || currentNode.data.type === 'start') {
        // Procurar pr√≥ximo node
        const nextEdge = edges.find(e => e.source === currentNodeId);
        currentNodeId = nextEdge ? nextEdge.target : null;
        continue;
      }

      // Converter node para step - copia todas as props do data
      const step = {
        id: currentNode.id,
        type: currentNode.data.type
      };

      // Copiar todas as propriedades do data para o step
      Object.keys(currentNode.data).forEach(key => {
        if (key !== 'label' && key !== 'type') {
          step[key] = currentNode.data[key];
        }
      });

      // Valida√ß√µes baseadas no novo tipo
      const displayName = step.customName || NODE_TYPES[step.type]?.label || step.type;

      if ((step.type === 'leftClick' || step.type === 'rightClick') && !step.position) {
        alert(`‚ùå N√≥ "${displayName}" (ID: ${step.id}) precisa ter uma posi√ß√£o capturada.\n\nClique em ‚úèÔ∏è e depois em "üìç Capturar Posi√ß√£o" para definir onde clicar.`);
        return;
      }

      if (step.type === 'checkRegion' && !step.region) {
        alert(`‚ùå N√≥ "${displayName}" (ID: ${step.id}) precisa ter uma regi√£o capturada.\n\nClique em ‚úèÔ∏è e depois em "üì∏ Capturar Regi√£o" para definir a √°rea a verificar.`);
        return;
      }

      if (step.type === 'checkRegion' && (!Array.isArray(step.modifierList) || step.modifierList.length === 0)) {
        alert(`‚ùå N√≥ "${displayName}" (ID: ${step.id}) precisa ter ao menos 1 modificador.\n\nClique em ‚úèÔ∏è, pesquise o mod e adicione √† lista.`);
        return;
      }

      // Debug: log do step
      console.log(`[Flow Debug] Step ${step.id} (${step.type}):`, step);

      steps.push(step);

      // Procurar pr√≥ximo node
      const nextEdge = edges.find(e => e.source === currentNodeId);
      currentNodeId = nextEdge ? nextEdge.target : null;
    }

    const flowData = { nodes, edges };
    flowData.metadata = {
      ...flowMetadata,
      nodeCount: nodes.length,
      edgeCount: edges.length
    };
    if (ipcRenderer) ipcRenderer.send('save-flow', flowData);
    alert('‚úÖ Fluxo salvo com sucesso!');
  };

  const handleExportFlow = () => {
    const exportData = {
      version: '1.0',
      nodes,
      edges,
      metadata: {
        ...flowMetadata,
        createdAt: flowMetadata?.createdAt || new Date().toISOString(),
        nodeCount: nodes.length,
        edgeCount: edges.length
      }
    };

    if (ipcRenderer) {
      ipcRenderer.send('export-flow', exportData);
    }
  };

  const handleImportFlow = () => {
    if (ipcRenderer) {
      ipcRenderer.send('import-flow-request');
    }
  };

  // Listener para quando o flow for importado
  useEffect(() => {
    if (!ipcRenderer) return;

    const handleFlowImported = (event, flowData) => {
      if (flowData && flowData.nodes && flowData.edges) {
        console.log('[Flow Import] Importando flow:', flowData);
        setNodes(flowData.nodes);
        setEdges(flowData.edges);
        if (flowData.metadata) {
          setFlowMetadata(flowData.metadata);
        }
        alert(`‚úÖ Flow importado com sucesso!\n\n${flowData.nodes.length} n√≥s e ${flowData.edges.length} conex√µes carregados.`);
      }
    };

    ipcRenderer.on('flow-imported', handleFlowImported);

    return () => {
      ipcRenderer.removeListener('flow-imported', handleFlowImported);
    };
  }, [setNodes, setEdges]);

  const onConnect = useCallback((params) => {
    setEdges((eds) => {
      if (params.source === 'start' && eds.some(e => e.source === 'start')) return eds;
      return addEdge({
        ...params,
        type: 'deletable',
        animated: true,
        style: { stroke: '#d4a351', strokeWidth: 2.5, filter: 'drop-shadow(0 0 4px rgba(212, 163, 81, 0.5))' },
        markerEnd: { type: MarkerType.ArrowClosed, color: '#d4a351', width: 20, height: 20 },
        pathOptions: { borderRadius: 16 }
      }, eds);
    });
  }, [setEdges]);

  const handleClearAll = () => {
    if (confirm('‚ö†Ô∏è Deseja realmente apagar TODOS os n√≥s e conex√µes?\n\nEsta a√ß√£o n√£o pode ser desfeita!')) {
      setNodes([
        { id: 'start', type: 'node', data: { label: NODE_TYPES.start.label, type: 'start' }, position: { x: 250, y: 50 }, deletable: false },
        { id: 'end', type: 'node', data: { label: NODE_TYPES.end.label, type: 'end' }, position: { x: 250, y: 400 }, deletable: false },
      ]);
      setEdges([]);
    }
  };

  return (
    <div style={{ width: '100%', height: '100%', display: 'flex', flexDirection: 'column', background: 'linear-gradient(135deg, #0b0a0f 0%, #12101a 50%, #0e0c14 100%)', borderRadius: '12px', border: '2px solid rgba(212, 163, 81, 0.4)', overflow: 'hidden', boxShadow: '0 12px 40px rgba(0, 0, 0, 0.6), 0 0 0 1px rgba(212, 163, 81, 0.1) inset' }}>
      <div style={{ padding: '14px 16px', background: 'linear-gradient(135deg, rgba(20, 17, 26, 0.95), rgba(28, 25, 34, 0.9))', borderBottom: '2px solid rgba(212, 163, 81, 0.4)', display: 'flex', gap: '12px', alignItems: 'center', flexShrink: 0, boxShadow: '0 2px 12px rgba(0,0,0,0.4)' }}>
        <button onClick={handleClearAll} style={{ padding: '8px 14px', background: 'linear-gradient(135deg, #ff6b6b, #e85555)', border: '1px solid rgba(255, 107, 107, 0.5)', borderRadius: '8px', color: '#fff', fontWeight: '600', cursor: 'pointer', fontSize: '0.82rem', boxShadow: '0 4px 12px rgba(255, 107, 107, 0.3)', transition: 'all 0.2s ease' }}>üóëÔ∏è Limpar Tudo</button>
        <button onClick={handleAutoLayout} style={{ padding: '8px 14px', background: 'linear-gradient(135deg, #8b7ba8, #9d8cbd)', border: '1px solid rgba(139, 123, 168, 0.5)', borderRadius: '8px', color: '#fff', fontWeight: '600', cursor: 'pointer', fontSize: '0.82rem', boxShadow: '0 4px 12px rgba(139, 123, 168, 0.3)', transition: 'all 0.2s ease' }}>üîÑ Auto-organizar</button>
        <div style={{ flex: 1 }}></div>
        <button onClick={handleImportFlow} style={{ padding: '8px 14px', background: 'linear-gradient(135deg, #5b9bd5, #4a8ac4)', border: '1px solid rgba(91, 155, 213, 0.5)', borderRadius: '8px', color: '#fff', fontWeight: '600', cursor: 'pointer', fontSize: '0.82rem', boxShadow: '0 4px 12px rgba(91, 155, 213, 0.3)', transition: 'all 0.2s ease' }}>üìÇ Importar</button>
        <button onClick={handleExportFlow} style={{ padding: '8px 14px', background: 'linear-gradient(135deg, #e77c40, #d86f35)', border: '1px solid rgba(231, 124, 64, 0.5)', borderRadius: '8px', color: '#fff', fontWeight: '600', cursor: 'pointer', fontSize: '0.82rem', boxShadow: '0 4px 12px rgba(231, 124, 64, 0.3)', transition: 'all 0.2s ease' }}>üì§ Exportar</button>
        <button onClick={handleSave} style={{ padding: '8px 14px', background: 'linear-gradient(135deg, #6bd17c, #5bc46c)', border: '1px solid rgba(107, 209, 124, 0.5)', borderRadius: '8px', color: '#0a1a0f', fontWeight: '600', cursor: 'pointer', fontSize: '0.82rem', boxShadow: '0 4px 12px rgba(107, 209, 124, 0.4)', transition: 'all 0.2s ease' }}>üíæ Salvar</button>
      </div>

      <div style={{ flex: 1, overflow: 'hidden', position: 'relative', display: 'flex' }}>
        {/* Toolbar Lateral */}
        <div style={{
          width: '150px',
          background: 'linear-gradient(180deg, rgba(20, 17, 26, 0.95), rgba(28, 25, 34, 0.92))',
          borderRight: '2px solid rgba(212, 163, 81, 0.4)',
          padding: '16px 12px',
          display: 'flex',
          flexDirection: 'column',
          gap: '12px',
          flexShrink: 0,
          boxShadow: '2px 0 12px rgba(0,0,0,0.3)'
        }}>
          <div style={{ fontSize: '0.75rem', color: '#d4a351', fontWeight: 'bold', marginBottom: '4px', textAlign: 'center' }}>
            üé® FERRAMENTAS
          </div>
          <ToolbarItem
            type="leftClick"
            label="Clique Esquerdo"
            icon="üëÜ"
            color="#6bd17c"
            onAddNode={handleAddNode}
          />
          <ToolbarItem
            type="rightClick"
            label="Clique Direito"
            icon="üëâ"
            color="#d4a351"
            onAddNode={handleAddNode}
          />
          <ToolbarItem
            type="checkRegion"
            label="Checar √Årea"
            icon="üîç"
            color="#f0b45a"
            onAddNode={handleAddNode}
          />
          <ToolbarItem
            type="delay"
            label="Delay"
            icon="‚è±Ô∏è"
            color="#8b7ba8"
            onAddNode={handleAddNode}
          />
          <div style={{
            marginTop: 'auto',
            padding: '8px',
            background: 'rgba(212, 163, 81, 0.1)',
            borderRadius: '6px',
            fontSize: '0.65rem',
            color: '#b9a98a',
            lineHeight: '1.3',
            textAlign: 'center'
          }}>
            üí° Clique ou arraste para o canvas
          </div>
        </div>

        {/* Canvas do ReactFlow */}
        <div ref={reactFlowWrapper} style={{ flex: 1, overflow: 'hidden' }}>
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onEdgeMouseEnter={(_, edge) => setHoveredEdgeId(edge.id)}
            onEdgeMouseLeave={() => setHoveredEdgeId(null)}
            onInit={setReactFlowInstance}
            onDrop={onDrop}
            onDragOver={onDragOver}
            nodeTypes={nodeTypes}
            edgeTypes={edgeTypes}
            fitView
            deleteKey={null}
            onKeyDown={(event) => {
              // Permitir que inputs recebam eventos de teclado
              if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                return;
              }
            }}
          >
            <Controls style={{
              position: 'absolute',
              bottom: '16px',
              left: '16px',
              button: {
                background: 'rgba(28, 25, 34, 0.9)',
                border: '1px solid rgba(212, 163, 81, 0.35)',
                color: '#f6f1e4',
                transition: 'all 0.2s ease'
              }
            }} />
            <Background
              color="rgba(212, 163, 81, 0.25)"
              gap={20}
              size={1.5}
              style={{ opacity: 0.15 }}
            />
          </ReactFlow>
        </div>
      </div>

      <div style={{ padding: '10px 16px', background: 'linear-gradient(135deg, rgba(20, 17, 26, 0.95), rgba(28, 25, 34, 0.9))', borderTop: '2px solid rgba(212, 163, 81, 0.4)', fontSize: '0.75rem', color: '#b9a98a', flexShrink: 0, boxShadow: '0 -2px 12px rgba(0,0,0,0.3)', textAlign: 'center' }}>
        ‚úèÔ∏è Editar ‚Ä¢ üñ±Ô∏è Arrastar ‚Ä¢ ‚û°Ô∏è Conectar
      </div>
    </div>
  );
}

if (typeof window !== 'undefined') {
  window.initFlowEditor = function (containerId) {
    const container = document.getElementById(containerId);
    if (container) {
      const root = createRoot(container);
      root.render(<FlowEditor />);
    }
  };
}

export default FlowEditor;
